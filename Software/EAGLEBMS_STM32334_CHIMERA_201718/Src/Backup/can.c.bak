/**
 * @file		can.h
 * @brief		This file contains some CAN functions to ease data transmission
 *
 * @author	Gregor
 * @author	Matteo Bonora [matteo.bonora@studenti.unitn.it]
 */

#include "can.h"

uint8_t CAN_MSG_INVERTER_VOLTAGE[8] = {0x3D, 0xEB, 0, 0, 0, 0, 0, 0};
uint8_t CAN_MSG_TS_ON[8] = {CAN_OUT_TS_ON, 0, 0, 0, 0, 0, 0, 0};
uint8_t CAN_MSG_TS_OFF[8] = {CAN_OUT_TS_OFF, 0, 0, 0, 0, 0, 0, 0};

CAN_FilterTypeDef runFilter; // CAN filter used during regular use
CAN_FilterTypeDef pcFilter;  // CAN filter used during precharge cycle

void can_init_msg(uint8_t data[8])
{
	uint8_t i = 0;
	for (i = 0; i < 8; i++)
	{
		data[i] = 0;
	}
}

void can_init(CAN_HandleTypeDef *canh)
{
	// CAN Filter Initialization
	runFilter.FilterMode = CAN_FILTERMODE_IDLIST;
	runFilter.FilterIdLow = 0x55 << 5;
	runFilter.FilterIdHigh = 0xA8 << 5;
	runFilter.FilterMaskIdHigh = 0x55 << 5;
	runFilter.FilterMaskIdLow = 0x55 << 5;
	runFilter.FilterFIFOAssignment = CAN_FILTER_FIFO0;
	runFilter.FilterScale = CAN_FILTERSCALE_16BIT;
	runFilter.FilterActivation = ENABLE;

	pcFilter.FilterMode = CAN_FILTERMODE_IDLIST;
	pcFilter.FilterIdLow = 0x181 << 5;
	pcFilter.FilterIdHigh = 0x181 << 5;
	pcFilter.FilterMaskIdHigh = 0x181 << 5;
	pcFilter.FilterMaskIdLow = 0x181 << 5;
	pcFilter.FilterFIFOAssignment = CAN_FILTER_FIFO0;
	pcFilter.FilterScale = CAN_FILTERSCALE_16BIT;
	pcFilter.FilterActivation = ENABLE;

	can_filter_normal(canh);
}

/*/uint8_t can_receive(CAN_HandleTypeDef *canh, CAN_RxHeaderTypeDef *rx,
					uint8_t *data)
{

	if (HAL_CAN_GetRxFifoFillLevel(canh, CAN_RX_FIFO0) != 0)
	{
		HAL_CAN_GetRxMessage(canh, CAN_RX_FIFO0, rx, data);
	}

	return rx->StdId;
}*/

void can_filter_precharge(CAN_HandleTypeDef *canh)
{
	HAL_CAN_ConfigFilter(canh, &pcFilter);
}
void can_filter_normal(CAN_HandleTypeDef *canh)
{
	HAL_CAN_ConfigFilter(canh, &runFilter);
}

bool can_check_error(CAN_HandleTypeDef *canh)
{
	return HAL_CAN_GetState(canh) == HAL_CAN_ERROR_BOF;
}

int can_send(can_stc *can, uint8_t data[8])
{

	uint32_t mailbox;
	uint8_t flag = 0;

	CAN_TxHeaderTypeDef TxHeader;
	TxHeader.StdId = can->id;
	TxHeader.IDE = CAN_ID_STD;
	TxHeader.RTR = CAN_RTR_DATA;
	TxHeader.DLC = can->size;
	TxHeader.TransmitGlobalTime = DISABLE;

	if (HAL_CAN_GetTxMailboxesFreeLevel(can->hcan) != 0 &&
		HAL_CAN_IsTxMessagePending(can->hcan, CAN_TX_MAILBOX0) == 0)
	{
		HAL_CAN_AddTxMessage(can->hcan, &TxHeader, data, &mailbox);
		flag = 1;
	}

	return flag;
}

// receive a buffer from the CAN communication
// you can call this function in the callback of the CAN interrupt
// hcan = pointer to can port
// DataRx = pointer to the buffer you are receiveng
// size = size of the buffer you are using
int can_receive(can_stc *can)
{

	CAN_RxHeaderTypeDef RxHeader;

	if (HAL_CAN_GetRxFifoFillLevel(can->hcan, CAN_RX_FIFO0) != 0)
	{
		HAL_CAN_GetRxMessage(can->hcan, CAN_RX_FIFO0, &RxHeader, can->dataRx);
	}

	int id = RxHeader.StdId;

	return id;
}

/**
 * @brief		This function is used to transmit a CAN message
 *
 * @param		canh	The CAN configuration structure
 * @param		id		The message ID
 * @param		DLC		TheMessage length
 * @param		data	The data to send
 */
/*int can_send(can_stc *can, uint8_t data[8])
{
	CAN_TxHeaderTypeDef TxMsg;
	TxMsg.IDE = CAN_ID_STD;
	TxMsg.StdId = id;
	TxMsg.DLC = DLC;
	TxMsg.RTR = CAN_RTR_DATA;

	uint32_t mailbox;

	if (HAL_CAN_GetTxMailboxesFreeLevel(canh) != 0 &&
		HAL_CAN_IsTxMessagePending(canh, CAN_TX_MAILBOX0 + CAN_TX_MAILBOX1 +
											 CAN_TX_MAILBOX2) == 0)
	{
		HAL_CAN_AddTxMessage(canh, &TxMsg, data, &mailbox);
	}
}*/

void can_request_inverter_voltage(CAN_HandleTypeDef *canh)
{
	can_stc can;
	can.hcan = canh;
	can.id = CAN_ID_BMS;
	can.size = 8;

	can_send(&can, CAN_MSG_INVERTER_VOLTAGE);
}

void can_send_ts_off(CAN_HandleTypeDef *canh)
{
	can_stc can;
	can.hcan = canh;
	can.id = CAN_ID_BMS;
	can.size = 8;

	can_send(&can, CAN_MSG_TS_OFF);
}

void can_send_ts_on(CAN_HandleTypeDef *canh)
{
	can_stc can;
	can.hcan = canh;
	can.id = CAN_ID_BMS;
	can.size = 8;

	can_send(&can, CAN_MSG_TS_ON);
}

/**
 * @brief		Send current data via CAN
 *
 * @param		canh		CAN configuration structure
 * @param		current	The current variable
 */
void can_send_current(CAN_HandleTypeDef *canh, int32_t current)
{
	// Send current data via CAN

	can_stc can;
	can.hcan = canh;
	can.id = CAN_ID_BMS;
	can.size = 8;

	uint8_t data[8];

	data[0] = CAN_OUT_CURRENT;
	data[1] = (int8_t)(current >> 16);
	data[2] = (int8_t)(current >> 8);
	data[3] = (int8_t)current;
	data[4] = 0;
	data[5] = 0;
	data[6] = 0;
	data[7] = 0;
	can_send(&can, data);
}

/**
 * @brief		Send pack data via CAN
 *
 * @param		canh	CAN configuration structure
 * @param		pack	The pack structure with data to send
 */
void can_send_pack_voltage(CAN_HandleTypeDef *canh, PACK_T pack)
{

	can_stc can;
	can.hcan = canh;
	can.id = CAN_ID_BMS;
	can.size = 8;

	uint8_t data[8];

	data[0] = CAN_OUT_PACK_VOLTS;
	data[1] = (uint8_t)(pack.total_voltage >> 16);
	data[2] = (uint8_t)(pack.total_voltage >> 8);
	data[3] = (uint8_t)(pack.total_voltage);
	data[4] = (uint8_t)(pack.max_voltage >> 8);
	data[5] = (uint8_t)(pack.max_voltage);
	data[6] = (uint8_t)(pack.min_voltage >> 8);
	data[7] = (uint8_t)(pack.min_voltage);
	can_send(&can, data);
}

/**
 * @brief		Send pack data via CAN
 *
 * @param		canh	CAN configuration structure
 * @param		pack	The pack structure with data to send
 */
void can_send_pack_temperature(CAN_HandleTypeDef *canh, PACK_T pack)
{

	can_stc can;
	can.hcan = canh;
	can.id = CAN_ID_BMS;
	can.size = 8;

	uint8_t data[8];

	data[0] = CAN_OUT_PACK_TEMPS;
	data[1] = (uint8_t)(pack.avg_temperature >> 8);
	data[2] = (uint8_t)(pack.avg_temperature);
	data[3] = (uint8_t)(pack.max_temperature >> 8);
	data[4] = (uint8_t)(pack.max_temperature);
	data[5] = (uint8_t)(pack.min_temperature >> 8);
	data[6] = (uint8_t)(pack.min_temperature);
	data[7] = 0;
	can_send(&can, data);
}

/**
 * @brief		Recognise and send errors over can
 *
 * @param		canh	CAN configuration structure
 * @param		error	The error type to send
 * @param		pack	The pack structure with data to send
 */
void can_send_error(CAN_HandleTypeDef *canh, ERROR_T error, uint8_t index,
					PACK_T *pack)
{

	can_stc can;
	can.hcan = canh;
	can.id = CAN_ID_BMS;
	can.size = 8;

	uint8_t data[8];
	can_init_msg(data);
	data[0] = CAN_OUT_ERROR;

	switch (error)
	{
	case ERROR_LTC6804_PEC_ERROR:
		data[1] = 0x02;
		data[2] = 0;
		data[3] = index; // Should be ltc index
		break;
	case ERROR_CELL_UNDER_VOLTAGE:
		data[1] = 0x02;
		data[2] = 0x01;
		data[3] = index; // Should be cell index
		data[4] = (uint8_t)(pack->min_voltage >> 8);
		data[5] = (uint8_t)pack->min_voltage;
		break;
	case ERROR_CELL_OVER_VOLTAGE:
		data[1] = 0x02;
		data[2] = 0x02;
		data[3] = index; // Should be cell index
		data[4] = (uint8_t)(pack->max_voltage >> 8);
		data[5] = (uint8_t)pack->max_voltage;
		break;
	case ERROR_CELL_OVER_TEMPERATURE:
		data[1] = 0x03;
		data[2] = 0x02;
		data[3] = index; // Should be cell index
		data[4] = (uint8_t)(pack->max_temperature >> 8);
		data[5] = (uint8_t)pack->max_temperature;
		break;
	case ERROR_OVER_CURRENT:
		break;
	case ERROR_PRECHARGE_ERROR:
		break;
	default:
		break;
	}

	can_send(&can, data);
}
